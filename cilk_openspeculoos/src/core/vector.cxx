/*
* 
* This file is part of OpenSPECULOOS
* Copyright (c) 2008 Ecole Polytechnique Federale de Lausanne (EPFL)
*
* Contact: Nicolas Fietier, EPFL, Station 9, 1015 Lausanne, Switzerland
* E-mail:  nicolas.fietier@epfl.ch
*
* OpenSPECULOOS is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.

* OpenSPECULOOS is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.

* You should have received a copy of the GNU General Public License
* along with OpenSPECULOOS.  If not, see <http://www.gnu.org/licenses/>.
* 
*/

// vector.cxx

#include "core/vector.hxx"


//________________________________ RealVector _________________________________

void RealVector :: Divide (RealVector* x)
{
    // y = y / x .
    // Substitutes every coefficient y(i) of the receiver 'y' by y(i)/x(i).

# ifdef REQUIRE
    Require("y and x have same size", size == x->size) ;
    InMethod("RealVector::Divide(x)") ;
# endif

    real *valuesX ;
    int  i ;

    valuesX = x->values ;
    for (i=0 ; i<size ; i++){
#ifdef CHECK
	if (fabs(valuesX[i]) < DEFAULT_TOLERANCE)
	{
	    printf(" FATAL ERROR DIVIDE BY ZERO \n" );
	    Exit();
	}
#endif    
	values[i] /= valuesX[i] ;
    }
}


real RealVector :: Dot (RealVector* x)
{
    // dot = y(transp) x .
    // Returns the scalar product of the receiver 'y' and 'x'.

# ifdef REQUIRE
    Require("y and x have same size", size == x->size) ;
    InMethod("RealVector::Dot(x)") ;
# endif

    int ione=IONE ;

    return DDOT(&size, &x->values[0], &ione, &values[0], &ione) ;
}


RealVector* RealVector :: Duplicate ()
{
    // Returns a new vector, a copy of the receiver.

    RealVector *answer ;

    answer = new RealVector(size) ;
    answer->CopyFrom(this) ;

    return answer ;
}


real RealVector :: GetEuclidianNorm ()
{
    // Returns the euclidian norm of the receiver.

    return sqrt(Dot(this)) ;
}


real RealVector :: GetInfiniteNorm ()
{
    // Returns the infinite norm (max norm) of the receiver.

    real answer ;
    int  i ;

    answer = ZERO ;
    for (i=0 ; i<size ; i++)
	answer = max(answer,fabs(values[i])) ;

    return answer ;
}


void RealVector :: Inverse ()
{
    // y = 1 / y .
    // Substitutes every coefficient of the receiver by its inverse. 

# ifdef REQUIRE
    Require("all coefficients are non null", ! Has(ZERO)) ;
    InMethod("RealVector::Inverse()") ;
# endif

    int  i ;

    for (i=0 ; i<size ; i++){
#ifdef CHECK
	if (fabs(values[i]) < DEFAULT_TOLERANCE)
	{
	    printf(" FATAL ERROR DIVIDE BY ZERO \n" );
	    Exit();
	}
#endif
	values[i] = ONE / values[i] ;
    }
}
  

void RealVector :: Multiply (real alpha)
{
    // y = alpha y .
    // Multiplies the receiver by 'alpha'.

    int ione = IONE ;

    // test due to a bug generated by PURIFY or BLAS!
# ifndef PURIFY
    DSCAL(&size, &alpha, &values[0], &ione) ;
# else
    for (int i=0 ; i<size ; i++)
	values[i] *= alpha ;
# endif
}


void RealVector :: Multiply (RealVector* x)
{
    // y = y * x .
    // Substitutes every coefficient y(i) of the receiver 'y' by y(i)*x(i).
    //
    // Remark. Profiling tests show that 10% to 20% of total execution time is
    //         typically spent in this method. Unfortunately there seems to exist
    //         no corresponding BLAS routine to speed it up. 
    //         Unrolling the loop below (using series of 16) led no improvement.

# ifdef REQUIRE
    Require("y and x have same size", size == x->size) ;
    InMethod("RealVector::Multiply(x)") ;
# endif

    real *valuesX ;
    int  i ;

    valuesX = x->values ;

    // Optimization: double-hammer align on BlueGene
# ifdef BLUE_GENE
    //#pragma disjoint (*values, *valuesX)
    //__alignx (16, values);
    //__alignx (16, valuesX);    
    //#pragma unroll(10)
# endif

    for (i=0 ; i<size ; i++)
	values[i] *= valuesX[i] ;

}


void RealVector :: MultiplyAndAdd (real alpha, RealVector* x, real beta)
{
    // y = alpha*y + beta*x .
    // Multiplies the receiver 'y' by 'alpha' then adds 'beta * x'.

# ifdef REQUIRE
    Require("y and x have same size", size == x->size) ;
    InMethod("RealVector::MultiplyAndAdd(alpha,x,beta)") ;
# endif

    real *valuesX ;
    int  i ; 

    valuesX = x->values ;

    if (beta == ONE)
	for (i=0 ; i<size ; i++) {
	    values[i] *= alpha ;
	    values[i] += valuesX[i] ;
	}

    else
	for (i=0 ; i<size ; i++) {
	    values[i] *= alpha ;
	    values[i] += beta*valuesX[i] ;
	}
}


void RealVector :: MultiplyAndSwitchSigns (RealVector* x)
{
    // y = - y * x .
    // Substitutes every coefficient y(i) of the receiver 'y' by -y(i)*x(i).
    // Returns 'y'.

# ifdef REQUIRE
    Require("y and x have same size", size == x->size) ;
    InMethod("RealVector::MultiplyAndSwitchSigns(x)") ;
# endif

    real *valuesX ;
    int  i ;

    valuesX = x->values ;
    for (i=0 ; i<size ; i++)
	values[i] *= -valuesX[i] ;
}


void RealVector :: Print ()
{
    // Prints the receiver on standard output.

    int i ;
    const int PER_LINE = 7 ;   // number of values printed on every line

    printf("RealVector of size %d:\n  ",size) ;

    for (i=1  ; i<=size ; i++) {
	printf (" % .4e",At(i)) ;
	if (i%PER_LINE==0 && i!=size)
	    printf ("\n  ") ;
    }
    printf ("\n") ;
}

void RealVector :: SetValuesZero ()
{
    // Sets to 0 every coefficient of the receiver.
    // Should be more efficient than invoking SetValues(ZERO).

    real zero=ZERO ;
    int  ione=IONE ;

    if (values)
	DSCAL(&size, &zero, &values[0], &ione) ;
}


void RealVector :: Square ()
{
    // y = square(y). 
    // Replaces every coefficient of the receiver by its square.

    int i ;

    for (i=0 ; i<size ; i++)
	values[i] *= values[i] ;
}

void RealVector :: Sqrt ()
{
    // y = sqrt(y).
    // Replaces every coefficient of the receiver by its square root.
    // Every coefficient is expected to be non-negative.

    int i ;

# ifdef CHECK
    for (i=0 ; i<size ; i++)
	if (values[i] < ZERO)
	    Error("RealVector::Sqrt()","has negative values") ;
# endif

    for (i=0 ; i<size ; i++)
	values[i] = sqrt(values[i]) ;
}


void RealVector :: Power (real x)
{
  // MAH 04.2006
  // y = y^x

  int i ;

  for (i=0 ; i<size ; i++)
    values[i] = pow(values[i],x) ;
} 


real RealVector :: SumValues ()
{
    // Returns the sum of the values of the receiver.
    // Possible improvement: calling DSUM on SG or DEC machines.

    real answer ;
    int  i ;

    answer = ZERO ;
    for (i=0 ; i<size ; i++)
	answer += values[i] ;

    return answer ;
}

void RealVector :: SetToConstant (real constant)
{
    int j ;

    j=(int)(size/2) ;
    values[j-1] = constant ;
}

//__________________________________ Mpi_Buffer _______________________________


Mpi_Buffer :: Mpi_Buffer ()
    : RealVector()
{
    // Constructor.

    start = 0 ;
}


void Mpi_Buffer :: Append (int n, real* x, int incr)
{
    // Appends to the receiver 'n' values from 'x', namely,
    //   if 'incr' > 0: x[0],  x[incr], x[2*incr], x[3*incr], etc;
    //   if 'incr' < 0: x[(n-1)*incr], x[(n-2)*incr], ..., x[incr], x[0]. 
    // This ordering is that of the BLAS function DCOPY.
    //
    // The receiver's size is increment by 'n'. The receiver is physically 
    // enlarged (re-allocated) if necessary.
    //
    // This method should be called "Put" rather than "Append", but some 
    // compilers refuse it.

# ifdef REQUIRE
    Require("n >= 0", n >= 0) ;
    InMethod("Mpi_Buffer::Append(n,x,incr)") ;
# endif

    int i, ione=IONE ;

    if (size+n > allocatedSize)                          // slow case
	for (i=0 ; i<n ; i++)
	    if (incr > 0)
		Put(x[i*incr]) ;
	    else
		Put(x[(n-i-1)*(-incr)]) ;

    else {                                               // fast case
	if (n == 1)
	    values[size] = x[0] ;
	else
	    DCOPY(&n, &x[0], &incr, &values[size], &ione) ;
	size += n ;
    }
}


void Mpi_Buffer :: Get (int n, real* x, int incr, int mode)
{
    // Gets the last 'n' coefficients of the receiver, then:
    // . if 'mode'=0, copies them into 'x';
    // . if 'mode'=1, addds them to 'x'.
    //
    // The initialized values of 'x' are:
    //   if 'incr' > 0: x[0],  x[incr], x[2*incr], x[3*incr], etc;
    //   if 'incr' < 0: x[(n-1)*incr], x[(n-2)*incr], ..., x[incr], x[0]. 
    // This ordering is that of the BLAS function DCOPY.
    //
    // The start index of the receiver is incremented by 'n', so as to update the
    // receiver for the next Get operation.

# ifdef REQUIRE
    Require("valid argument 'n'", n >= 0 && n <= size) ;
    InMethod("Mpi_Buffer::Get(n,x,incr,mode)") ;
# endif

    real one=ONE ;
    int  ione=IONE ;

    if (mode == 0) {   // copy mode
	if (n == 1)                                          // speed up this case
	    x[0] = values[start] ;
	else
	    DCOPY(&n, &values[start], &ione, &x[0], &incr) ;
    }

    else {             // add mode
	if (n == 1)                                          // speed up this case
	    x[0] += values[start] ;
	else
	    DAXPY(&n, &one, &values[start], &ione, &x[0], &incr) ;
    }

    start += n ;
}


int Mpi_Buffer :: GetStart ()
{
    // Returns the position of the cursor for reading/writing.
    // The answer is in {0,...,size-1}.

    return start ;
}

  
void Mpi_Buffer :: Reset ()
{
    // Reinitializes the receiver.

    size  = 0 ;
    start = 0 ;
}


